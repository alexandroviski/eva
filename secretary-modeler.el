;;; sc-modeler.el --- model the user  -*- lexical-binding: t; -*-

;;; Commentary:

;;; Code:

(require 'sc-lib)

(defun sc-loss-fn (prediction)
  "Input PREDICTION should be a list of probabilities, one for
each activity, adding up to 1."
  (let ((index 0)
        (result 0))
    (dolist (row sc-activities-alist result)
      (seq-let (id cost) row
        (setq result (+ result (* (nth index prediction) cost))))
      (setq index (1+ index)))))
;; (sc-loss-fn ')

(ert-deftest sc-test-loss-fn ()
  ;; (--iterate (- it (cl-random it)) 1.0 5) ;; try to make a list that adds up to 1 for use below
  (should (<= 0 (sc-loss-fn '(.8 .15 .01 .01 .01 .01 .01)))))

(defun sc-guess-activity ()
  (let* ((default-directory (f-dirname (find-library-name "secretary")))
         (script (expand-file-name "sc_activity.R")))
    (set-process-sentinel
     (start-process sc-ai-name (sc--buffer-r) "Rscript" script)
     (lambda (_process _event)
       (setq sc-guessed-activity-id
             (with-current-buffer (sc--buffer-r)
               (goto-char (point-max))
               (buffer-substring (line-beginning-position) (line-end-position))))
       (run-with-timer 30 nil #'sc-guess-activity)
       ))))
;; (sc-guess-activity)

(defun sc-guess-activity ()
  (let* ((default-directory (f-dirname (find-library-name "secretary")))
         (script (expand-file-name "sc_activity.R")))
    (set-process-sentinel
     (start-process sc-ai-name (sc--buffer-r) "Rscript" script)
     (lambda (_process _event)
       (mkdir "/tmp/secretary")
       ;; get a 2-column dataset with ids and probabilities
       (setq sc-activity-nowcast (->> (f-read "/tmp/secretary/activities")
                                      (s-split "\n")
                                      (-map #'split-string)))))))

;; Not actually of central interest to clock correctly in realtime (and due to
;; MCMC slowness, it'd come many minutes late), we primarily want facilites to
;; edit the clock history.
(defun sc-clock-in-to-guessed-activity ()
  (save-excursion
    (org-id-goto sc-guessed-activity-id)
    (org-clock-in)))

(defun sc-edit-clocks ()
  "Edit the :LOGBOOK: entries of specified headings retroactively
so they match what we know."
  ;; assume we can import a series of clock intervals, a
  ;; 2-column dataset with {interval, id} or simply {timestamp, id}.
  (let ((series (list (cons (ts-parse "2020-12-01 10:30:00") "some-uuid")
                      (cons (ts-parse "2020-12-01 11:30:00") "some-uuid2")
                      (cons (ts-parse "2020-12-01 12:30:00") "some-uuid3")
                      (cons (ts-parse "2020-12-01 13:30:00") "some-uuid")
                      (cons (ts-parse "2020-12-01 14:30:00") "some-uuid3"))))
    (dolist (x series)
      (save-excursion
        (org-id-goto (cdr x))
        (org-clock-out-if-current)
        ;; The problem is that there could be a long clock running from
        ;; yesterday, so we can't even search for the current da.
        (and (search-forward "2020")
             (search-forward "2020-01")
             (search-forward "2020-11")
             (search-forward "2020-12")
             (search-forward "2020-12-01"))
        ;; we could remember the last clock in each task that this module is
        ;; responsible for writing, then we could just delete every clock from
        ;; after that
        ;; or maybe mark the relevant lines  with a special comment at eol

        ;; we should generate entire org files containing only auto-written
        ;; data: the headlines, ids, and their logbooks. Not to be edited by
        ;; user. this exists only for the benefit of org-agenda log presentations.

        ;; maybe then we can even manually clock specific tasks and so long as
        ;; they belong to the correct general category, there's no problem. then
        ;; the program can just look for such clocks and leave holes for them in
        ;; the autogenerated logbooks.

        (org-clock-timestamps-change)
        )
      )
    ))
  


(provide 'sc-modeler)

;;; sc-modeler.el ends here
